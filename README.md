
# WebServer

练手写的http服务器，慢慢完善修改。

## 一、依赖环境

依赖库: 

1. [yaml-cpp](https://github.com/jbeder/yaml-cpp)
2. boost 1.74

目录结构:

| 目录名 | 作用 |
| :--- | :--- |
| include | 头文件(.h文件) |
| src | 源文件(.cpp文件) | 
| conf | 配置文件目录 |
| log | 日志文件目录 |
| htdocs | 前端静态界面文件 |

## 二、编译构建方式

```shell
mkdir build
cd build
cmake ../
make
```

## 三、各个模块的介绍

(编程全部完成后, 画个流程图补在这里)

### 3.1 日志模块

日志模块，实现日志记录功能。照目前的实现来看比较像是python的logger模块。

已有功能: 

* 支持日志分等级
* 自定义日志格式，细分到每一项需要记录的信息，如时间戳，线程ID，文件名，行号，日志级别。
* 自定义日志输出路径，可以是文件，控制台终端，网络socket(暂未支持...)
* 支持流式日志和格式化日志

待完善:

format的init函数最好重写一下，代码晦涩难懂，不好维护。

#### 工作流程

1. 初始化`LogFormatter`，`LogAppender`, `Logger`实例。
2. LogEvent表示一个日志事件（简单说就是需要记录一条日志），其中`LogFormatter`类会完成日志格式的解析。
3. 将日志项都封装为单独的类，在logger最开始设置`LogFormatter`参数时，日志项决定日志中会输出哪些信息。
4. 通过宏定义提供**流式风格**和**格式化风格**的日志接口，每次写日志时，通过宏自动生成对应的日志事件LogEvent。
5. LogEventWrap对象包装下，利用对象出作用域后自动调用析构函数这一特点**简化logger的使用方法**。LogEventWrap对象析构时，调用`Logger`的log方法将日志信息进行输出(打印)。

#### 主要的类

* LogEvent

  把记录日志当作一个事件，记录日志现场信息。具体的信息就是时间，文件名，行号，线程id等通用信息，以及实际代码日志消息。
  
* LogFormatItem

  日志项，可以包括
  
  1. 日志内容
  2. 日志器名称
  3. 日志级别
  4. 文件名和行号
  5. 程序运行时间
  6. 线程ID
  7. UTC时间戳
  8. 线程名称

* LogFormatter

  日志格式器，用于格式化日志事件，将所有日志项，转化成一串合适的字符串。

* LogAppender

  日志输出器，用于输出日志事件格式化后的字符串，这是一个虚基类，目前只有两个具体实现：
  
  1. 输出到控制终端，`StdoutLogAppender`，
  2. 输出到指定文件，`FileLogAppender`。
  3. 以后可以添加，输出到日志服（即网络上的其他机器）。

* Logger

  日志器，用于输出日志。这个类是**直接与用户进行交互的类**，提供一些接口用于记录日志。

* LogManager

  Logger管理类，单例模式，用于统一管理全部的日志器。提供getLogger()方法用于创建/获取日志器，内部维护一个名称到日志器的map，当获取的日志器存在时，直接返回对应的日志器指针，否则创建对应的日志器并返回。
  
  感觉没有什么必要，当前只用到了一个logger，可以不对外暴露，logger模块内部自己维护一下现有的logger对象。

### 3.2 配置模块

服务启动时读取相应配置文件，按照配置文件进行初始化，同时也需要解析命令行参数。

#### 已有功能

* yaml文件支持多级配置项，如`tcp.connect.timeout`。
* 可以对配置项注册回调函数，如果配置项的值变化，就会调用回调函数。

#### 待完善

* 更新配置值时，检测值是否合法。(不完善，目前只是判断类型是否正确，无法判断值的范围是否正确)
* 动态变更配置，且使得运行中的程序做出相应改变。(考虑定时读取一次配置文件，修改配置)

但是有一些配置变化可能不太好监控，比如port变化，就需要关闭旧的端口，用新的port去listen。这可能还涉及到现有的TCP连接迁移(或者维持旧的TCP连接等用户下线，同时开启新的port监听)，不是那么容易的。

#### 约定大于配置

* [约定大于配置](https://zh.wikipedia.org/wiki/%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE)的意思是：程序所依赖的配置项都有一个**公认的名字**和默认值，也就是约定。对于这些具有公认约定的配置，不需要程序运行前还进行设置。
* 约定大于配置的思想可以减少程序员做决定的数量，获得简单的配置，同时兼顾灵活性。
* **在代码实现上**，约定大于配置的思路体现为所有的配置项在定义时都带一个的默认值。在程序中定义过的配置才是合法配置。

#### 具体实现

配置文件是yaml格式，需要`yaml-cpp`库的支持。

ConfigItemBase基类有两个虚函数，toString和fromString。这两个函数的实现需要借助一些类型转化，毕竟C++标准库只提供了一部分类型和std::string的相互转换，像vector，map，set，自定义类型到string之间的转换就没有。需要自己实现。

然后实现一个ConfigManager类管理所有的配置项。主要提供两个接口loadFromYaml和loadFromCmd，用来从yaml配置文件和cmd参数中加载配置。读取yaml文件实际工作是由yaml-cpp库完成的。

通过ConfigManager对象管理配置时，**一定要先调用lookup接口，并且是有默认参数的接口**。后续读取配置文件只会读取通过lookup默认设置过的配置。其它配置项会被当成非法配置项。

程序中必须有这个配置，配置文件中写这个配置才有效。否则该配置非法。

### 3.3 线程模块

#### Thread封装

由于C++标准库的信号量，是在C++20才引入，所以还是使用POSIX线程库。POSIX都是一些函数接口，于是想实现一个std::thread的Thread类。

1. 使用POSIX线程库封装一个类似std::thread的Thread类，实现返回**当前线程名, 当前线程ID**的接口。
2. 构造函数可以设置线程名，线程名在debug时还是比较有用的，可以直接看出是什么线程而不需要查看代码。
3. 封装POSIX的一些信号量，条件变量，互斥锁。因为使用C++标准库提供的线程同步机制，去控制POSIX线程有点奇怪，所以整套线程，线程同步机制都是POSIX库。(C++标准的线程库和POSIX线程库混用，好像也没啥问题，但是看起来很奇怪....)

#### ThreadPool

线程池对象，通过上面封装好的Thread和Semaphore类实现。

1. 构造函数固定线程数
2. 任务可以是任何**可调用对象**，使用互斥量保护任务队列的线程安全。
3. 消费者生产者模式，使用信号量通知新任务的到来。(C++官方文档也有说信号量性能比条件变量略好，所以使用信号量)
4. 通过std::future返回任务结果。
5. 关闭时完成所有任务，析构时不允许增加新的任务，同时保证剩余任务全部执行完毕后，再关闭线程池。

### 3.4 定时器模块

定时器的作用：**设置某个任务在规定时间执行**。

定时器的实现，常见的几种方式就是：

1. 双向有序列表
2. 时间堆
3. 时间轮
4. 借用Linux系统自带的timer fd。

#### 具体实现

时间轮的实现稍微复杂一些，后续再研究...

目前这里选择的是时间堆。本来是打算使用`std::priority_queue`自己实现一个简单的时间堆。

但是偶然看到Mariadb的时间堆定时器实现，写得非常nice，直接参考一下。

且MySQL实现的堆相比于`std::priority_queue`而言有一个优点是，**可以删除堆中的任意一个元素**，而不仅仅是堆顶元素。

后续改进点:

定时器任务合并。同一个时间点的任务合并为一个计时任务，减少内存开销（实际上也减少不了多少）。

### 3.5 HTTP请求处理

核心的业务需求，http服务器，主要的就是提供http服务呗。

目前还没想好怎么写......

## 四、整个工作流程

main函数整个工作流程:

1. 读取配置文件，命令行参数。
2. 设置信号处理函数，比如忽视掉socket的SIGPIPE信号。
3. 设置守护进程。
4. 多线程epoll实例，进行监听和工作...
5. epoll唤醒之后，出发http协议解析，任务执行等等。

## 改进点

1. main函数，需要改进整个程序工作流程。
2. 对于http协议解析，还需要重新设计重写。
3. poller提供io多路复用的功能，具体内部实现可能是使用poll，epoll等实现。
4. 收发数据，要注意实际情况，也就是如果无法完成数据收发，应该设置一个最长时间限制。收发数据超时就断开连接。减少资源，线程占用。
